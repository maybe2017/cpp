//
// Created by 98596 on 2023/6/14.
//

// 初始化列表方式的构造函数
// 嵌套类 属性用初始化列表赋值 构造与析构的顺序问题
// Static类变量 为啥必须在类外初始化？？

// 空对象字节数 内存对齐？？成员函数与静态函数的存放位置 this指针(空指针可以调用成员函数，函数内注意this判空？？)
// 链式调用函数的写法 要返回引用 而不是值（注意拷贝函数的调用场景）
// 每个成员函数中默认会有个this指针，本质-指针常量，const常函数（相当于双const修饰）
// const常函数的写法，本质是(确保不能修改没有加mutable的属性)；常对象，常对象只能调用常函数(确保不能修改没有加mutable的属性)

// 全局函数做友元、类做友元、类中的成员函数 可实现访问私有成员

// 运算符重载 << 递增 注意前置与后置返回值 是引用还是值

// =赋值运算符重载 注意浅拷贝引发的内存重复释放问题(=重载与拷贝构造重载实现中解决)
// 函数调用符()重载 仿函数 注意匿名对象调用仿函数的方式


// 继承(多重)写法 class 子类: 继承方式(public、protect、private) 父类, 继承方式(public、protect、private) 父类
// 首先，无论如何，子类不能访问父类的私有成员（私有变量可以通过父类protect、public的方法进行访问，与Java一样的道理）
// protect继承: 父类的public属性在子类中被升级为protect权限
// private继承：父类的public及protect属性在子类中被升级为private权限

// 虚继承写法 class 子类: virtual 继承方式(public、protect、private) 父类；解决菱形继承子类存在多份父类相同变量的数据问题(vbptr)
// 动态多态: 虚函数可以实现让形式参数的地址晚绑定(虚函数使基类函数的地址不确定) 从而实现运行时多态(子类重写了父类的虚函数: 注意，重写了那么)
// 子类重写了父类的虚函数: 注意，重写了那么子类该函数也是虚函数! 所以子类有自己的虚函数表，该方法指针vfptr(占8字节)，指向子类自身的虚函数地址，所以运行时调用的是自身的方法。
// vbptr 虚基类指针 指向 虚基类表；vfptr 虚函数指针 指向 虚函数表
// 创建对象时，创建虚函数表指针; 虚函数表(类层级)是编译器在编译期间确定。