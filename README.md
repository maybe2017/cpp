### 记录c/c++学习过程
1. 最近想深入看下Java中线程的锁、阻塞唤醒等机制是如何实现的，最后追溯到了Java Hotspot源码，发现是c++写的，于是抽空学点c++..
2. 有台mac在公司用，不想每天上下班都提个电脑包跑来跑去，就把家里的台式利用起来，两个机器上的学习代码就用github来同步吧..

### 与Java明显不一样的地方
#### 数组
1. Java中的数组本身就是一个对象，而C++中数组是一种基础数据类型；Java数组分配在堆上，C++可以分配在栈、堆(new)都行。
2. 创建方式，C++中可以用如 int arr[10]; 就表示在栈上创建了一个长度为10的数组，元素的默认值为0；而Java仅是表示声明，后续还必须初始化(安全性)
3. Java中创建如Person pArr[] = new Person[10]类数组时，只是申请了一段内存空间，并没有为数组中每个元素调用构造函数；
4. C++中new[]操作符(默认的)就会去先申请空间, 接着执行构造函数，所以创建对象类型的数组时，对象必须具有默认的构造函数。

#### 类
1. 类对象的创建，Java对象均分配在堆上，C++可以分配在栈、堆(new)都行。
2. C++中类对象的创建如 Person p; 就表示调用无参构造在栈上创建了一个对象，而Java仅仅表示声明。
3. Java中函数形参或返回值为类类型的时候(值传递-引用类型)，如Person update(Person p){..}，传递地址的副本，这个时候入参和形参看做是两个对象，用两个相同的地址指针指向同一个内存位置。
4. C++中函数形参或返回值为类类型的时候(值传递)，如Person update(Person p){..return p;}，参数与返回值均是调用了拷贝构造函数在栈上创建了新对象。
5. Java中的引用，可以理解为就是指针，是一种限制的指针，不能参与整数运算和指向任意位置的内存，并且不用显示回收对象。
6. C++子类重写父类的方法(普通或静态)时，会覆盖掉父类所有重名的方法(与参数列表无关)，需要用父类作用域显示调用才行，不能通过形参列表区分；而Java可以。
7. C++子类支持多继承语法，父类若出现重名成员，用作用域区分；菱形继承问题由虚继承解决(解决子类含有多份父类中相同成员的问题)
8. C++的多态，需要用虚函数解决编译期函数地址早绑定的问题；


#### 坑
1. 在一个函数体内部，可以写另一个函数的声明。。
2. 隐式转换创建对象: Person p1 = 10; ==>> 相当于Person p1 = Person(10);   Person p2 = p1; ==>> 相当于Person p = Person(p1);